{% extends "base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    <style type="text/css">
        .important { color: #336699; }
        body { background: rgba(255, 187, 51, 0.41) !important; }
    </style>
{% endblock %}

{% block content %}

    <div class="container" style="min-height: 100%;  width: 80%">
        {% with messages = get_flashed_messages() %}
            {% if messages %}
                {% for message in messages %}
                    <div class="alert alert-info alert-success" role="alert">
                    {{ message }}
                    <button type="button" class="close" style="float: right" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}
    </div>

    <!-- Title Card -->
    <div class="jumbotron-fluid container text-center my-5">
          <div class="row">
               <span class="project_title">S.O.L.I.D.</span>
          </div>
         <div class="row">
            <span class="sub_title">S.O.L.I.D. Principles in Calculator</span>
         </div>
    </div>

    <!-- Main Container -->
    <div class="container justify-content-center text-black">

        <div class="row">

            <!-- Side Bar -->
            <div class="col-4 ordinary_type post_it">
                <div class="text-center my-2">
                    <span class="sub_title">Fundamental Concepts</span>
                </div>
                <div class="text-center">
                    <span class="middle_title">1. Single Responsibility Principle</span>
                </div>
                <div class="m-2">
                    <span class="ordinary_type">The Single Responsibility Principle requires that a class should have only one job. So if a class has more than one responsibility, it becomes coupled. A change to one responsibility results to modification of the other responsibility.</span>
                </div>

                <div class="text-center" style="margin-bottom: 5px">
                    <span class="middle_title">2. Open-Closed Principle</span><br>
                </div>
                <div class="m-2">
                    <span class="ordinary_type">Software entities such as Classes, modules, and functions should be open for extension, not modification.</span>
                </div>

                <div class="text-center" style="margin-bottom: 5px">
                    <span class="middle_title">3. Liskov Substitution Principle</span><br>
                </div>
                <div class="m-2">
                    <span class="ordinary_type">The main idea behind Liskov Subtitution Principle is that, for any class, a client should be able to use any of its subtypes indistinguishably, without even noticing, and therefore without compromising the expected behavior at runtime. This means that clients are completely isolated and unaware of changes in the class hierarchy.</span>
                </div>

                <div class="text-center" style="margin-bottom: 5px">
                    <span class="middle_title">4. Interface Segregation Principle</span><br>
                </div>
                <div class="m-2">
                    <span class="ordinary_type">Make fine grained interfaces that are client specific Clients should not be forced to depend upon interfaces that they do not use. This principle deals with the disadvantages of implementing big interfaces.</span>
                </div>

            </div>

            <!-- Primary Content -->
            <div class="col-8">

                <div class="mx-4 my-2 text-left" style="margin-top: 5px">
                    <span class="sub_title">1. Single Responsibility Principle</span>
                </div>
                <div class="mx-4 my-2">
                    <span class="middle_title">Calculator Example</span>
                </div>
                <div class="mx-4 my-3">
                    <span class="ordinary_type">Here is an example of how the job of the class "Calculation" doesn't actually do any calculating as it merely acquires a list of float values first, and then the separate classes for computing have their own individual classes. The calculation class could do both find float values and perform calculations, but that would violate the Single Responsibility Principle. For example here are also the "Addition" and "Subtraction" classes that all accomplish only one job, all seen below.</span>
                </div>

                <div class="py-5">
                    <img alt="encapsulation" src="{{ url_for('static', filename='images/calculation.png') }}" class="img-fluid p-2 py-5 w-75 rounded mx-auto d-block">
                    <img alt="encapsulation" src="{{ url_for('static', filename='images/inheritancesub.png') }}" class="img-fluid p-2 py-5 w-75 rounded mx-auto d-block">
                    <img alt="encapsulation" src="{{ url_for('static', filename='images/polymorphism.png') }}" class="img-fluid p-2 py-5 w-75 rounded mx-auto d-block">
                </div>

            </div>

        </div>

    </div>

    <!-- Break Title -->
    <div class="container justify-content-center text-center post_it">
        <div class="row">
            <span class="project_title">2. Open-Closed Principle</span>
        </div>
    </div>

    <!-- Secondary content container -->
    <div class="container">
        <div class="row mx-1">
            <div class="my-2 text-left" style="padding-top: 15px">
                <span class="sub_title">Calculator Example</span>
            </div>
            <div class="my-2">
                <span class="ordinary_type">For this principle, our example from above also happens to apply. Instead of adding simple if statements to the "Calculation" class, for example.</span>
            </div>
            <div class="my-2">
                <span class="ordinary_type">if self.calculation == 'addition'<br>
                return self.value + a</span>
            </div>
            <div class="my-2 py-3">
                <span class="ordinary_type">We instead create separate classes that extend Calculation, such as "Addition(Calculation)" and "Subtraction(Calculation)" to implement the new behavior.</span>
            </div>

        </div>
    </div>

    <!-- Break Title -->
    <div class="container justify-content-center text-center post_it">
        <div class="row">
            <span class="project_title">3. Liskov Substitution Principle</span>
        </div>
    </div>

    <!-- Secondary content container -->
    <div class="container">
        <div class="row mx-1">
            <div class="my-2 text-left" style="padding-top: 15px">
                <span class="sub_title">Calculator Example</span>
            </div>
            <div class="my-2">
                <span class="ordinary_type">In the class "Calculations" we get the history of calculations and is a great example of the Liskov Substitution Principle, as all specializations of the class are suitable by the parent or superclass.</span>
            </div>

            <br>
            <img alt="encapsulation" src="{{ url_for('static', filename='images/3liskov.png') }}" class="img-fluid p-2 py-5 w-75 rounded mx-auto d-block">

        </div>
    </div>

    <!-- Break Title -->
    <div class="container justify-content-center text-center post_it">
        <div class="row">
            <span class="project_title">4. Interface Segregation Principle</span>
        </div>
    </div>

    <!-- Secondary content container -->
    <div class="container">
        <div class="row mx-1">
            <div class="my-2 text-left" style="padding-top: 15px">
                <span class="sub_title">Calculator Example</span>
            </div>
            <div class="my-2">
                <span class="ordinary_type">In this example you can see here that the "Calculator" class provides us with our core interface segregations, resulting in loose coupling and easy testing.</span>
            </div>

            <br>
            <img alt="encapsulation" src="{{ url_for('static', filename='images/4interface.png') }}" class="img-fluid p-2 py-5 w-75 rounded mx-auto d-block">

        </div>
    </div>

    <!-- Break Title -->
    <div class="container justify-content-center text-center post_it">
        <div class="row">
            <span class="project_title">5. Dependency Inversion Principle</span>
        </div>
    </div>

    <!-- Secondary content container -->
    <div class="container">
        <div class="row mx-1">
            <div class="my-2 text-left" style="padding-top: 15px">
                <span class="sub_title">Calculator Example</span>
            </div>
            <div class="my-2">
                <span class="ordinary_type">For this example we go back to the "Calculator" class, low level, that generates float values, and the many actual calculation classes, high level, such as "Addition" and "Subtraction". They don't depend on themselves, but they do depend on abstractions. The client simply enacts the calculator and gets a result.</span>
            </div>

            <br>
            <img alt="encapsulation" src="{{ url_for('static', filename='images/calculation.png') }}" class="img-fluid p-2 py-5 w-75 rounded mx-auto d-block">
            <br>

            <br>
            <img alt="encapsulation" src="{{ url_for('static', filename='images/inheritancesub.png') }}" class="img-fluid p-2 py-5 w-75 rounded mx-auto d-block">
            <br>

            <br>
            <img alt="encapsulation" src="{{ url_for('static', filename='images/polymorphism.png') }}" class="img-fluid p-2 py-5 w-75 rounded mx-auto d-block">

        </div>
    </div>

{% endblock %}